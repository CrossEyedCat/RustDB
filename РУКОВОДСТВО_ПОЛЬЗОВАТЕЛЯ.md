# Руководство пользователя RustDB

## Содержание
1. [Введение](#введение)
2. [Установка](#установка)
3. [Быстрый старт](#быстрый-старт)
4. [Конфигурация](#конфигурация)
5. [SQL операции](#sql-операции)
6. [Управление транзакциями](#управление-транзакциями)
7. [Настройка производительности](#настройка-производительности)
8. [Устранение неполадок](#устранение-неполадок)
9. [Примеры](#примеры)

## Введение

RustDB — это высокопроизводительная система управления базами данных, написанная на Rust, которая обеспечивает соответствие принципам ACID. Она предоставляет надежную основу для приложений, требующих надежного хранения данных с гарантиями строгой согласованности.

### Ключевые возможности
- **Соответствие ACID**: Полная поддержка атомарности, согласованности, изоляции и долговечности
- **Высокая производительность**: Оптимизирована для параллельных операций с продвинутыми механизмами блокировок
- **Поддержка SQL**: Комплексная поддержка языка запросов SQL
- **Управление транзакциями**: Множественные уровни изоляции и обнаружение взаимоблокировок
- **Система восстановления**: Автоматическое восстановление после сбоев с WAL (Write-Ahead Logging)
- **Инструменты отладки**: Встроенные возможности профилирования и отладки

## Установка

### Предварительные требования
- Rust 1.70+ (стабильная версия)
- 4GB+ RAM рекомендуется
- 1GB+ дискового пространства

### Сборка из исходного кода

```bash
# Клонирование репозитория
git clone https://github.com/your-org/rustdb.git
cd rustdb

# Сборка проекта
cargo build --release

# Запуск тестов для проверки установки
cargo test
```

### Установка через Docker

```bash
# Сборка Docker образа
docker build -t rustdb .

# Запуск контейнера
docker run -p 8080:8080 -v /path/to/data:/data rustdb
```

## Быстрый старт

### Запуск базы данных

```bash
# Запуск с конфигурацией по умолчанию
./target/release/rustdb

# Запуск с пользовательской конфигурацией
./target/release/rustdb --config config.toml
```

### Базовое подключение

```rust
use rustdb::Database;

// Подключение к базе данных
let db = Database::connect("localhost:8080").await?;

// Создание таблицы
db.execute("CREATE TABLE users (id INTEGER, name VARCHAR(100), email VARCHAR(255))").await?;

// Вставка данных
db.execute("INSERT INTO users VALUES (1, 'Иван Иванов', 'ivan@example.com')").await?;

// Запрос данных
let results = db.query("SELECT * FROM users WHERE id = 1").await?;
```

## Конфигурация

### Файл конфигурации (config.toml)

```toml
[database]
name = "mydb"
data_directory = "./data"
max_connections = 100

[storage]
page_size = 8192
buffer_pool_size = 1000
checkpoint_interval = 300

[logging]
level = "info"
file = "./logs/rustdb.log"
max_file_size = "100MB"
max_files = 10

[network]
host = "0.0.0.0"
port = 8080
max_connections = 1000

[performance]
query_timeout = 30
lock_timeout = 10
deadlock_detection_interval = 1000
```

### Переменные окружения

```bash
export RUSTDB_DATA_DIR="/var/lib/rustdb"
export RUSTDB_LOG_LEVEL="debug"
export RUSTDB_PORT="8080"
```

## SQL операции

### Язык определения данных (DDL)

#### Создание таблиц

```sql
-- Базовое создание таблицы
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблица с ограничениями
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    amount DECIMAL(10,2) CHECK (amount > 0),
    status VARCHAR(20) DEFAULT 'pending'
);
```

#### Изменение таблиц

```sql
-- Добавление колонки
ALTER TABLE users ADD COLUMN age INTEGER;

-- Удаление колонки
ALTER TABLE users DROP COLUMN age;

-- Создание индекса
CREATE INDEX idx_users_email ON users(email);

-- Удаление индекса
DROP INDEX idx_users_email;
```

### Язык манипулирования данными (DML)

#### Операции вставки

```sql
-- Одиночная вставка
INSERT INTO users (name, email) VALUES ('Петр Петров', 'petr@example.com');

-- Множественные вставки
INSERT INTO users (name, email) VALUES 
    ('Анна Сидорова', 'anna@example.com'),
    ('Михаил Козлов', 'mikhail@example.com');

-- Вставка с подзапросом
INSERT INTO users (name, email)
SELECT name, email FROM temp_users WHERE verified = true;
```

#### Операции обновления

```sql
-- Обновление одной строки
UPDATE users SET email = 'newemail@example.com' WHERE id = 1;

-- Обновление нескольких строк
UPDATE users SET status = 'active' WHERE created_at < '2023-01-01';

-- Обновление с подзапросом
UPDATE orders SET status = 'shipped' 
WHERE user_id IN (SELECT id FROM users WHERE premium = true);
```

#### Операции удаления

```sql
-- Удаление конкретных строк
DELETE FROM users WHERE id = 1;

-- Удаление с условием
DELETE FROM orders WHERE status = 'cancelled' AND created_at < '2023-01-01';

-- Очистка таблицы
TRUNCATE TABLE temp_data;
```

### Операции запросов

#### Базовые запросы

```sql
-- Выбор всех колонок
SELECT * FROM users;

-- Выбор конкретных колонок
SELECT id, name, email FROM users;

-- Выбор с условием
SELECT * FROM users WHERE age > 18;

-- Выбор с сортировкой
SELECT * FROM users ORDER BY name ASC, created_at DESC;

-- Выбор с ограничением
SELECT * FROM users LIMIT 10 OFFSET 20;
```

#### Соединения (JOIN)

```sql
-- Внутреннее соединение
SELECT u.name, o.amount
FROM users u
INNER JOIN orders o ON u.id = o.user_id;

-- Левое соединение
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- Самосоединение
SELECT e1.name as employee, e2.name as manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.id;
```

#### Агрегация

```sql
-- Базовая агрегация
SELECT COUNT(*) as total_users FROM users;
SELECT AVG(amount) as avg_order FROM orders;
SELECT MAX(created_at) as latest_order FROM orders;

-- Группировка
SELECT status, COUNT(*) as count
FROM orders
GROUP BY status;

-- Условие HAVING
SELECT user_id, COUNT(*) as order_count
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 5;
```

## Управление транзакциями

### Основы транзакций

```rust
use rustdb::{Database, IsolationLevel};

let db = Database::connect("localhost:8080").await?;

// Начало транзакции
let tx = db.begin_transaction(IsolationLevel::ReadCommitted).await?;

// Выполнение операций в рамках транзакции
tx.execute("INSERT INTO users (name, email) VALUES ('Иван', 'ivan@example.com')").await?;
tx.execute("UPDATE accounts SET balance = balance - 100 WHERE user_id = 1").await?;

// Подтверждение транзакции
tx.commit().await?;
```

### Уровни изоляции

```rust
use rustdb::IsolationLevel;

// Read Committed (по умолчанию)
let tx1 = db.begin_transaction(IsolationLevel::ReadCommitted).await?;

// Repeatable Read
let tx2 = db.begin_transaction(IsolationLevel::RepeatableRead).await?;

// Serializable
let tx3 = db.begin_transaction(IsolationLevel::Serializable).await?;
```

### Обработка ошибок и откат

```rust
let tx = db.begin_transaction(IsolationLevel::ReadCommitted).await?;

match tx.execute("INSERT INTO users (name, email) VALUES ('Иван', 'ivan@example.com')").await {
    Ok(_) => {
        // Продолжение с дополнительными операциями
        match tx.execute("UPDATE accounts SET balance = balance - 100 WHERE user_id = 1").await {
            Ok(_) => tx.commit().await?,
            Err(e) => {
                // Откат при ошибке
                tx.rollback().await?;
                return Err(e);
            }
        }
    }
    Err(e) => {
        tx.rollback().await?;
        return Err(e);
    }
}
```

## Настройка производительности

### Оптимизация индексов

```sql
-- Создание индексов для часто запрашиваемых колонок
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_status ON orders(user_id, status);

-- Составные индексы для сложных запросов
CREATE INDEX idx_orders_date_status ON orders(created_at, status);

-- Частичные индексы для фильтрованных запросов
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';
```

### Оптимизация запросов

```sql
-- Использование EXPLAIN для анализа планов запросов
EXPLAIN SELECT * FROM users WHERE email = 'ivan@example.com';

-- Оптимизация соединений путем обеспечения правильных индексов
EXPLAIN SELECT u.name, o.amount
FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE u.status = 'active';
```

### Настройка конфигурации

```toml
[performance]
# Увеличение пула буферов для лучшего кэширования
buffer_pool_size = 2000

# Настройка частоты контрольных точек
checkpoint_interval = 600

# Настройка таймаутов блокировок
lock_timeout = 5
deadlock_detection_interval = 500

[storage]
# Оптимизация размера страницы для вашей рабочей нагрузки
page_size = 16384

# Включение сжатия для больших наборов данных
compression_enabled = true
```

## Устранение неполадок

### Частые проблемы

#### Проблемы с подключением

```bash
# Проверка запуска базы данных
ps aux | grep rustdb

# Проверка доступности порта
netstat -tlnp | grep 8080

# Проверка логов
tail -f logs/rustdb.log
```

#### Проблемы с производительностью

```sql
-- Проверка активных подключений
SHOW CONNECTIONS;

-- Проверка статуса блокировок
SHOW LOCKS;

-- Проверка статуса транзакций
SHOW TRANSACTIONS;

-- Анализ медленных запросов
SHOW SLOW_QUERIES;
```

#### Разрешение взаимоблокировок

```rust
use rustdb::DeadlockResolution;

// Настройка стратегии разрешения взаимоблокировок
let config = DatabaseConfig::default()
    .with_deadlock_resolution(DeadlockResolution::YoungestTransactionWins)
    .with_deadlock_detection_interval(Duration::from_millis(1000));

let db = Database::connect_with_config("localhost:8080", config).await?;
```

### Анализ логов

```bash
# Мониторинг логов ошибок
grep "ERROR" logs/rustdb.log

# Проверка метрик производительности
grep "SLOW_QUERY" logs/rustdb.log

# Мониторинг событий взаимоблокировок
grep "DEADLOCK" logs/rustdb.log
```

## Примеры

### Интеграция с веб-приложением

```rust
use rustdb::Database;
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Инициализация базы данных
    let db = Database::connect("localhost:8080").await?;
    
    // Создание таблиц
    db.execute("CREATE TABLE IF NOT EXISTS posts (
        id INTEGER PRIMARY KEY,
        title VARCHAR(255) NOT NULL,
        content TEXT,
        author_id INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )").await?;
    
    // Запуск веб-сервера
    let listener = TcpListener::bind("0.0.0.0:3000").await?;
    
    loop {
        let (stream, _) = listener.accept().await?;
        let db = db.clone();
        
        tokio::spawn(async move {
            handle_connection(stream, db).await;
        });
    }
}

async fn handle_connection(stream: TcpStream, db: Database) {
    // Обработка HTTP запросов и операций с базой данных
    // Детали реализации...
}
```

### Пакетная обработка

```rust
use rustdb::Database;

async fn batch_insert_users(db: &Database, users: Vec<User>) -> Result<(), Box<dyn std::error::Error>> {
    let tx = db.begin_transaction(IsolationLevel::ReadCommitted).await?;
    
    for user in users {
        tx.execute(&format!(
            "INSERT INTO users (name, email, age) VALUES ('{}', '{}', {})",
            user.name, user.email, user.age
        )).await?;
    }
    
    tx.commit().await?;
    Ok(())
}
```

### Миграция данных

```rust
use rustdb::Database;

async fn migrate_data(db: &Database) -> Result<(), Box<dyn std::error::Error>> {
    // Создание новой структуры таблицы
    db.execute("CREATE TABLE users_v2 (
        id INTEGER PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(255) UNIQUE NOT NULL,
        full_name VARCHAR(100),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )").await?;
    
    // Миграция данных
    db.execute("INSERT INTO users_v2 (id, username, email, full_name)
        SELECT id, name, email, name FROM users").await?;
    
    // Удаление старой таблицы
    db.execute("DROP TABLE users").await?;
    
    // Переименование новой таблицы
    db.execute("ALTER TABLE users_v2 RENAME TO users").await?;
    
    Ok(())
}
```

## Поддержка и ресурсы

### Получение помощи
- **Документация**: [Полная справочная информация по API](API_REFERENCE.md)
- **Проблемы**: [GitHub Issues](https://github.com/your-org/rustdb/issues)
- **Обсуждения**: [GitHub Discussions](https://github.com/your-org/rustdb/discussions)

### Участие в разработке
- **Код**: [Руководство по участию](CONTRIBUTING.md)
- **Архитектура**: [Руководство по архитектуре](ARCHITECTURE_GUIDE.md)
- **Тестирование**: Запустите `cargo test` для проверки ваших изменений

### Лицензия
Этот проект лицензирован под лицензией MIT - см. файл [LICENSE](LICENSE) для подробностей.
