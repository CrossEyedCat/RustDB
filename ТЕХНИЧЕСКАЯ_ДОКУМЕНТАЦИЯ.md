# Техническая документация RustDB

## Содержание
1. [Архитектура системы](#архитектура-системы)
2. [Движок хранения](#движок-хранения)
3. [Обработка запросов](#обработка-запросов)
4. [Управление транзакциями](#управление-транзакциями)
5. [Управление конкурентностью](#управление-конкурентностью)
6. [Система восстановления](#система-восстановления)
7. [Сетевой уровень](#сетевой-уровень)
8. [Оптимизация производительности](#оптимизация-производительности)
9. [Безопасность](#безопасность)
10. [Руководство по разработке](#руководство-по-разработке)

## Архитектура системы

### Высокоуровневая архитектура

RustDB следует паттерну многоуровневой архитектуры с четким разделением ответственности:

```
┌─────────────────────────────────────────────────────────────┐
│                    Уровень приложения                      │
├─────────────────────────────────────────────────────────────┤
│                    Сетевой уровень                         │
├─────────────────────────────────────────────────────────────┤
│                    Уровень обработки запросов              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Парсер    │ │ Планировщик │ │ Исполнитель │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    Уровень транзакций                      │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   ACID      │ │ Менеджер    │ │   MVCC      │           │
│  │ Менеджер    │ │ блокировок  │ │ Менеджер    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    Уровень хранения                        │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Буфер     │ │   Страницы  │ │   Индексы   │           │
│  │ Менеджер    │ │ Менеджер    │ │ Менеджер    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    Уровень файловой системы                │
└─────────────────────────────────────────────────────────────┘
```

### Основные компоненты

#### 1. Движок хранения
- **Менеджер страниц**: Управляет страницами базы данных и их выделением
- **Менеджер буферов**: Реализует LRU кэширование для часто используемых страниц
- **Менеджер файлов**: Обрабатывает операции низкоуровневого ввода-вывода файлов
- **Менеджер индексов**: Управляет B+ деревьями и хеш-индексами

#### 2. Обработка запросов
- **SQL Парсер**: Преобразует SQL текст в абстрактные синтаксические деревья (AST)
- **Семантический анализатор**: Валидирует запросы и разрешает ссылки на объекты
- **Планировщик запросов**: Генерирует планы выполнения
- **Оптимизатор запросов**: Оптимизирует планы выполнения для лучшей производительности
- **Исполнитель**: Выполняет оптимизированные планы с использованием различных операторов

#### 3. Управление транзакциями
- **ACID Менеджер**: Обеспечивает атомарность, согласованность, изоляцию и долговечность
- **Менеджер блокировок**: Реализует гранулярные блокировки с обнаружением взаимоблокировок
- **MVCC Менеджер**: Предоставляет многоверсионное управление конкурентностью
- **Менеджер восстановления**: Обрабатывает восстановление после сбоев и контрольные точки

#### 4. Сетевой уровень
- **Менеджер подключений**: Управляет подключениями клиентов
- **Обработчик протокола**: Реализует протокол базы данных
- **Аутентификация**: Обрабатывает аутентификацию и авторизацию пользователей

## Движок хранения

### Структура страницы

Каждая страница базы данных имеет фиксированный размер (по умолчанию 8KB) и содержит:

```rust
pub struct Page {
    pub header: PageHeader,
    pub data: [u8; PAGE_SIZE],
    pub free_space: usize,
    pub slot_directory: Vec<SlotEntry>,
}

pub struct PageHeader {
    pub page_id: PageId,
    pub page_type: PageType,
    pub lsn: LogSequenceNumber,
    pub checksum: u32,
    pub free_space_offset: u16,
    pub slot_count: u16,
}
```

### Управление пулом буферов

Пул буферов использует политику вытеснения LRU (Least Recently Used):

```rust
pub struct BufferManager {
    pool: HashMap<PageId, Arc<Mutex<Page>>>,
    lru_list: LinkedList<PageId>,
    max_pages: usize,
    stats: BufferStats,
}

impl BufferManager {
    pub async fn pin_page(&self, page_id: PageId) -> Result<PageRef, Error> {
        // Проверить, находится ли страница в пуле буферов
        if let Some(page) = self.pool.get(&page_id) {
            self.update_lru(page_id);
            return Ok(PageRef::new(page.clone()));
        }
        
        // Загрузить страницу с диска
        let page = self.load_page_from_disk(page_id).await?;
        self.insert_page(page_id, page).await
    }
}
```

### Реализация индексов

#### B+ дерево индекс

```rust
pub struct BPlusTree<K, V> {
    root: Option<BTreeNode<K, V>>,
    order: usize,
    height: usize,
}

pub enum BTreeNode<K, V> {
    Internal {
        keys: Vec<K>,
        children: Vec<Box<BTreeNode<K, V>>>,
    },
    Leaf {
        keys: Vec<K>,
        values: Vec<V>,
        next: Option<Box<BTreeNode<K, V>>>,
    },
}
```

#### Хеш индекс

```rust
pub struct HashIndex<K, V> {
    buckets: Vec<Vec<(K, V)>>,
    hash_function: fn(&K) -> u64,
    load_factor: f64,
    size: usize,
}
```

## Обработка запросов

### Парсинг SQL

Парсер использует подход рекурсивного спуска:

```rust
pub struct SqlParser {
    tokens: Vec<Token>,
    current: usize,
}

impl SqlParser {
    pub fn parse(&mut self) -> Result<SqlStatement, Error> {
        match self.peek() {
            Some(Token::Select) => self.parse_select(),
            Some(Token::Insert) => self.parse_insert(),
            Some(Token::Update) => self.parse_update(),
            Some(Token::Delete) => self.parse_delete(),
            Some(Token::Create) => self.parse_create(),
            _ => Err(Error::UnexpectedToken),
        }
    }
}
```

### Планирование запросов

Планировщик генерирует планы выполнения, используя подход на основе стоимости:

```rust
pub struct QueryPlanner {
    statistics: Arc<StatisticsManager>,
    optimizer: QueryOptimizer,
}

impl QueryPlanner {
    pub fn create_plan(&self, query: &SelectStatement) -> Result<ExecutionPlan, Error> {
        // 1. Создать базовый план
        let base_plan = self.create_base_plan(query)?;
        
        // 2. Применить оптимизации
        let optimized_plan = self.optimizer.optimize(base_plan)?;
        
        // 3. Оценить стоимость
        let cost = self.estimate_cost(&optimized_plan)?;
        
        Ok(ExecutionPlan {
            root: optimized_plan,
            cost,
            metadata: PlanMetadata::new(),
        })
    }
}
```

### Операторы выполнения

#### Оператор сканирования таблицы

```rust
pub struct TableScanOperator {
    table_name: String,
    page_manager: Arc<PageManager>,
    current_page: Option<PageId>,
    current_slot: usize,
}

impl Operator for TableScanOperator {
    async fn next(&mut self) -> Result<Option<Row>, Error> {
        loop {
            if let Some(page_id) = self.current_page {
                let page = self.page_manager.read_page(page_id).await?;
                
                if self.current_slot < page.slot_count() {
                    let row = page.get_row(self.current_slot)?;
                    self.current_slot += 1;
                    return Ok(Some(row));
                } else {
                    // Перейти к следующей странице
                    self.current_page = page.next_page();
                    self.current_slot = 0;
                }
            } else {
                return Ok(None);
            }
        }
    }
}
```

#### Операторы соединения

```rust
pub struct NestedLoopJoinOperator {
    left_child: Box<dyn Operator>,
    right_child: Box<dyn Operator>,
    join_condition: JoinCondition,
    left_row: Option<Row>,
}

impl Operator for NestedLoopJoinOperator {
    async fn next(&mut self) -> Result<Option<Row>, Error> {
        loop {
            if self.left_row.is_none() {
                self.left_row = self.left_child.next().await?;
                if self.left_row.is_none() {
                    return Ok(None);
                }
            }
            
            if let Some(right_row) = self.right_child.next().await? {
                if self.join_condition.evaluate(&self.left_row.as_ref().unwrap(), &right_row)? {
                    return Ok(Some(self.combine_rows(&self.left_row.as_ref().unwrap(), &right_row)));
                }
            } else {
                // Сбросить правый дочерний элемент и перейти к следующей левой строке
                self.right_child.reset().await?;
                self.left_row = None;
            }
        }
    }
}
```

## Управление транзакциями

### Реализация свойств ACID

#### Атомарность
Обеспечивается через Write-Ahead Log (WAL):

```rust
impl AcidManager {
    pub async fn begin_transaction(&self, isolation_level: IsolationLevel) -> Result<TransactionId, Error> {
        let tx_id = self.generate_transaction_id();
        
        // Записать начало транзакции в лог
        let log_record = LogRecord {
            lsn: self.get_next_lsn(),
            transaction_id: tx_id,
            record_type: LogRecordType::BeginTransaction,
            timestamp: SystemTime::now(),
        };
        
        self.wal.write_record(log_record).await?;
        self.register_transaction(tx_id, isolation_level);
        
        Ok(tx_id)
    }
}
```

#### Согласованность
Поддерживается через проверку ограничений:

```rust
impl AcidManager {
    pub async fn check_constraints(&self, table_id: TableId, row: &Row) -> Result<(), Error> {
        let schema = self.schema_manager.get_table_schema(table_id)?;
        
        for constraint in &schema.constraints {
            match constraint {
                Constraint::NotNull(column_index) => {
                    if row.get_value(*column_index).is_null() {
                        return Err(Error::ConstraintViolation("Нарушено ограничение NOT NULL"));
                    }
                }
                Constraint::Unique(columns) => {
                    if self.check_unique_constraint(table_id, columns, row).await? {
                        return Err(Error::ConstraintViolation("Нарушено ограничение UNIQUE"));
                    }
                }
                _ => {}
            }
        }
        
        Ok(())
    }
}
```

#### Изоляция
Реализуется через блокировки и MVCC:

```rust
impl LockManager {
    pub async fn acquire_lock(
        &self,
        transaction_id: TransactionId,
        resource: ResourceId,
        lock_mode: LockMode,
    ) -> Result<(), Error> {
        let mut lock_table = self.lock_table.lock().await;
        
        // Проверить конфликты блокировок
        if self.has_lock_conflict(&lock_table, &resource, &lock_mode) {
            // Добавить в очередь ожидания
            self.add_to_waiting_queue(transaction_id, resource, lock_mode).await?;
            
            // Проверить на взаимоблокировку
            if self.detect_deadlock(transaction_id).await? {
                return Err(Error::Deadlock);
            }
            
            // Ожидать блокировку
            self.wait_for_lock(transaction_id, resource).await?;
        }
        
        // Предоставить блокировку
        self.grant_lock(&mut lock_table, transaction_id, resource, lock_mode);
        Ok(())
    }
}
```

#### Долговечность
Гарантируется через WAL и контрольные точки:

```rust
impl AcidManager {
    pub async fn commit_transaction(&self, transaction_id: TransactionId) -> Result<(), Error> {
        // Записать подтверждение транзакции в лог
        let log_record = LogRecord {
            lsn: self.get_next_lsn(),
            transaction_id,
            record_type: LogRecordType::CommitTransaction,
            timestamp: SystemTime::now(),
        };
        
        self.wal.write_record(log_record).await?;
        self.wal.flush().await?; // Обеспечить долговечность
        
        // Освободить блокировки
        self.lock_manager.release_all_locks(transaction_id).await?;
        
        // Удалить из активных транзакций
        self.remove_transaction(transaction_id);
        
        Ok(())
    }
}
```

## Управление конкурентностью

### Гранулярность блокировок

RustDB поддерживает несколько уровней блокировок:

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LockGranularity {
    Database,
    Table,
    Page,
    Row,
}
```

### Матрица совместимости блокировок

| Режим блокировки | IS | IX | S | SIX | X |
|------------------|----|----|----|-----|---|
| IS               | ✓  | ✓  | ✓  | ✓   | ✗ |
| IX               | ✓  | ✓  | ✗  | ✗   | ✗ |
| S                | ✓  | ✗  | ✓  | ✗   | ✗ |
| SIX              | ✓  | ✗  | ✗  | ✗   | ✗ |
| X                | ✗  | ✗  | ✗  | ✗   | ✗ |

### Обнаружение взаимоблокировок

Использует граф ожидания для обнаружения взаимоблокировок:

```rust
impl LockManager {
    pub async fn detect_deadlock(&self, transaction_id: TransactionId) -> Result<bool, Error> {
        let wait_for_graph = self.build_wait_for_graph().await?;
        
        // Использовать DFS для обнаружения циклов
        let mut visited = HashSet::new();
        let mut recursion_stack = HashSet::new();
        
        for &tx_id in wait_for_graph.keys() {
            if !visited.contains(&tx_id) {
                if self.has_cycle(&wait_for_graph, tx_id, &mut visited, &mut recursion_stack) {
                    return Ok(true);
                }
            }
        }
        
        Ok(false)
    }
}
```

### Реализация MVCC

```rust
pub struct MVCCManager {
    version_chains: HashMap<RowId, VersionChain>,
    active_transactions: HashMap<TransactionId, TransactionInfo>,
}

pub struct Version {
    pub version_id: VersionId,
    pub transaction_id: TransactionId,
    pub begin_timestamp: Timestamp,
    pub end_timestamp: Option<Timestamp>,
    pub data: Vec<u8>,
    pub next_version: Option<VersionId>,
}

impl MVCCManager {
    pub async fn get_visible_version(
        &self,
        row_id: RowId,
        transaction_id: TransactionId,
    ) -> Result<Option<Version>, Error> {
        let chain = self.version_chains.get(&row_id)?;
        let tx_info = self.active_transactions.get(&transaction_id)?;
        
        for version in chain.versions() {
            if self.is_version_visible(version, tx_info) {
                return Ok(Some(version.clone()));
            }
        }
        
        Ok(None)
    }
}
```

## Система восстановления

### Write-Ahead Logging

Все изменения записываются в лог перед применением к страницам данных:

```rust
impl WriteAheadLog {
    pub async fn write_record(&self, record: LogRecord) -> Result<LogSequenceNumber, Error> {
        let lsn = self.get_next_lsn();
        let log_entry = LogEntry {
            lsn,
            record,
            checksum: self.calculate_checksum(&record),
        };
        
        // Записать в файл лога
        self.log_file.write(&log_entry.serialize()).await?;
        
        // Обновить буфер лога в памяти
        self.log_buffer.push(log_entry);
        
        Ok(lsn)
    }
}
```

### Контрольные точки

Периодические контрольные точки сокращают время восстановления:

```rust
impl CheckpointManager {
    pub async fn create_checkpoint(&self) -> Result<(), Error> {
        // 1. Сбросить все грязные страницы
        self.buffer_manager.flush_all_dirty_pages().await?;
        
        // 2. Записать запись контрольной точки
        let checkpoint_record = LogRecord {
            lsn: self.wal.current_lsn(),
            transaction_id: TransactionId::new(0),
            record_type: LogRecordType::Checkpoint {
                active_transactions: self.get_active_transactions(),
                dirty_pages: self.get_dirty_pages(),
            },
            timestamp: SystemTime::now(),
        };
        
        self.wal.write_record(checkpoint_record).await?;
        self.wal.flush().await?;
        
        // 3. Обновить файл контрольной точки
        self.update_checkpoint_file().await?;
        
        Ok(())
    }
}
```

### Восстановление после сбоя

Трехфазный процесс восстановления:

```rust
impl RecoveryManager {
    pub async fn recover(&self) -> Result<RecoveryResult, Error> {
        // Фаза 1: Анализ
        let analysis_result = self.analyze_log().await?;
        
        // Фаза 2: Redo
        let redo_result = self.redo_phase(&analysis_result).await?;
        
        // Фаза 3: Undo
        let undo_result = self.undo_phase(&analysis_result).await?;
        
        Ok(RecoveryResult {
            analysis: analysis_result,
            redo: redo_result,
            undo: undo_result,
        })
    }
    
    async fn analyze_log(&self) -> Result<AnalysisResult, Error> {
        let mut active_transactions = HashSet::new();
        let mut dirty_pages = HashSet::new();
        
        // Найти последнюю контрольную точку
        let checkpoint_lsn = self.find_last_checkpoint().await?;
        
        // Сканировать лог с контрольной точки
        let log_iter = self.wal.read_from(checkpoint_lsn).await?;
        
        for log_entry in log_iter {
            match &log_entry.record.record_type {
                LogRecordType::BeginTransaction { transaction_id } => {
                    active_transactions.insert(*transaction_id);
                }
                LogRecordType::CommitTransaction { transaction_id } => {
                    active_transactions.remove(transaction_id);
                }
                LogRecordType::AbortTransaction { transaction_id } => {
                    active_transactions.remove(transaction_id);
                }
                LogRecordType::Insert { table_id, .. } => {
                    dirty_pages.insert(*table_id);
                }
                _ => {}
            }
        }
        
        Ok(AnalysisResult {
            active_transactions,
            dirty_pages,
        })
    }
}
```

## Сетевой уровень

### Управление подключениями

```rust
pub struct ConnectionManager {
    connections: HashMap<ConnectionId, Arc<Connection>>,
    max_connections: usize,
    connection_timeout: Duration,
}

impl ConnectionManager {
    pub async fn accept_connection(&self, stream: TcpStream) -> Result<ConnectionId, Error> {
        if self.connections.len() >= self.max_connections {
            return Err(Error::TooManyConnections);
        }
        
        let connection_id = ConnectionId::new();
        let connection = Arc::new(Connection::new(stream, connection_id));
        
        // Запустить обработчик подключения
        let connection_clone = connection.clone();
        tokio::spawn(async move {
            connection_clone.handle_requests().await;
        });
        
        self.connections.insert(connection_id, connection);
        Ok(connection_id)
    }
}
```

### Реализация протокола

```rust
pub struct ProtocolHandler {
    database: Arc<Database>,
}

impl ProtocolHandler {
    pub async fn handle_request(&self, request: Request) -> Result<Response, Error> {
        match request {
            Request::Query { sql } => {
                let result = self.database.execute(&sql).await?;
                Ok(Response::QueryResult(result))
            }
            Request::Prepare { sql } => {
                let stmt = self.database.prepare(&sql).await?;
                Ok(Response::PreparedStatement(stmt))
            }
            Request::Execute { stmt_id, params } => {
                let stmt = self.get_prepared_statement(stmt_id)?;
                let result = self.database.execute_prepared(&stmt, &params).await?;
                Ok(Response::QueryResult(result))
            }
            Request::BeginTransaction { isolation_level } => {
                let tx = self.database.begin_transaction(isolation_level).await?;
                Ok(Response::TransactionStarted(tx.id()))
            }
            Request::Commit { transaction_id } => {
                let tx = self.get_transaction(transaction_id)?;
                tx.commit().await?;
                Ok(Response::TransactionCommitted)
            }
            Request::Rollback { transaction_id } => {
                let tx = self.get_transaction(transaction_id)?;
                tx.rollback().await?;
                Ok(Response::TransactionRolledBack)
            }
        }
    }
}
```

## Оптимизация производительности

### Оптимизация запросов

#### Оптимизация на основе стоимости

```rust
impl QueryOptimizer {
    pub fn optimize(&self, plan: ExecutionPlan) -> Result<ExecutionPlan, Error> {
        let mut optimized_plan = plan;
        
        // Применить правила оптимизации
        optimized_plan = self.push_down_selections(optimized_plan)?;
        optimized_plan = self.push_down_projections(optimized_plan)?;
        optimized_plan = self.reorder_joins(optimized_plan)?;
        optimized_plan = self.choose_join_algorithms(optimized_plan)?;
        
        Ok(optimized_plan)
    }
    
    fn reorder_joins(&self, plan: ExecutionPlan) -> Result<ExecutionPlan, Error> {
        // Использовать динамическое программирование для поиска оптимального порядка соединений
        let join_nodes = self.extract_join_nodes(&plan);
        let optimal_order = self.find_optimal_join_order(join_nodes)?;
        
        self.rebuild_plan_with_join_order(plan, optimal_order)
    }
}
```

#### Сбор статистики

```rust
pub struct StatisticsManager {
    table_stats: HashMap<TableId, TableStatistics>,
    column_stats: HashMap<ColumnId, ColumnStatistics>,
}

pub struct TableStatistics {
    pub row_count: usize,
    pub page_count: usize,
    pub average_row_size: f64,
    pub last_updated: SystemTime,
}

pub struct ColumnStatistics {
    pub distinct_values: usize,
    pub null_count: usize,
    pub min_value: Option<Value>,
    pub max_value: Option<Value>,
    pub histogram: Histogram,
}
```

### Выбор индексов

```rust
impl QueryOptimizer {
    pub fn choose_best_index(
        &self,
        table_id: TableId,
        conditions: &[Condition],
    ) -> Result<Option<IndexId>, Error> {
        let available_indexes = self.index_manager.get_indexes_for_table(table_id)?;
        let mut best_index = None;
        let mut best_cost = f64::INFINITY;
        
        for index_id in available_indexes {
            let cost = self.estimate_index_cost(index_id, conditions)?;
            if cost < best_cost {
                best_cost = cost;
                best_index = Some(index_id);
            }
        }
        
        // Сравнить со стоимостью сканирования таблицы
        let table_scan_cost = self.estimate_table_scan_cost(table_id, conditions)?;
        if table_scan_cost < best_cost {
            return Ok(None);
        }
        
        Ok(best_index)
    }
}
```

## Безопасность

### Аутентификация

```rust
pub struct AuthenticationManager {
    users: HashMap<String, UserInfo>,
    password_hasher: PasswordHasher,
}

pub struct UserInfo {
    pub username: String,
    pub password_hash: String,
    pub permissions: Vec<Permission>,
    pub created_at: SystemTime,
    pub last_login: Option<SystemTime>,
}

impl AuthenticationManager {
    pub async fn authenticate(&self, username: &str, password: &str) -> Result<UserInfo, Error> {
        let user = self.users.get(username)
            .ok_or(Error::InvalidCredentials)?;
        
        if self.password_hasher.verify(password, &user.password_hash)? {
            Ok(user.clone())
        } else {
            Err(Error::InvalidCredentials)
        }
    }
}
```

### Авторизация

```rust
pub struct AuthorizationManager {
    permissions: HashMap<String, Vec<Permission>>,
}

#[derive(Debug, Clone)]
pub enum Permission {
    Select { table: String },
    Insert { table: String },
    Update { table: String },
    Delete { table: String },
    CreateTable,
    DropTable,
    CreateIndex,
    DropIndex,
}

impl AuthorizationManager {
    pub fn check_permission(&self, user: &UserInfo, permission: &Permission) -> bool {
        user.permissions.contains(permission) || 
        user.permissions.contains(&Permission::All)
    }
}
```

## Руководство по разработке

### Организация кода

```
src/
├── lib.rs                 # Точка входа библиотеки
├── main.rs               # Точка входа исполняемого файла
├── common/               # Общие утилиты и типы
│   ├── error.rs         # Определения ошибок
│   ├── types.rs         # Общие определения типов
│   └── utils.rs         # Утилитарные функции
├── storage/             # Движок хранения
│   ├── page.rs         # Управление страницами
│   ├── buffer.rs       # Пул буферов
│   ├── file.rs         # Ввод-вывод файлов
│   └── index/          # Реализации индексов
├── parser/              # Парсинг SQL
│   ├── lexer.rs        # Токенизация
│   ├── parser.rs       # Синтаксический анализ
│   └── ast.rs          # Абстрактное синтаксическое дерево
├── planner/             # Планирование запросов
│   ├── planner.rs      # Планирование запросов
│   └── optimizer.rs    # Оптимизация запросов
├── executor/            # Выполнение запросов
│   ├── operators.rs    # Операторы выполнения
│   └── executor.rs     # Движок выполнения
├── core/               # Основная функциональность базы данных
│   ├── transaction.rs  # Управление транзакциями
│   ├── lock.rs         # Блокировки
│   └── mvcc.rs         # Многоверсионное управление конкурентностью
├── logging/            # Логирование и восстановление
│   ├── wal.rs         # Write-ahead log
│   └── recovery.rs    # Восстановление после сбоя
├── network/            # Сетевой уровень
│   ├── server.rs      # Сервер базы данных
│   └── connection.rs  # Обработка подключений
└── debug/              # Отладка и профилирование
    ├── profiler.rs    # Профилирование производительности
    └── logger.rs      # Отладочное логирование
```

### Обработка ошибок

Используйте крейт `thiserror` для определений ошибок:

```rust
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Ошибка парсинга SQL: {message}")]
    SqlParsing { message: String },
    
    #[error("Ошибка выполнения: {message}")]
    Execution { message: String },
    
    #[error("Ошибка транзакции: {message}")]
    Transaction { message: String },
    
    #[error("Ошибка хранения: {message}")]
    Storage { message: String },
    
    #[error("Внутренняя ошибка: {message}")]
    Internal { message: String },
}
```

### Стратегия тестирования

#### Модульные тесты

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_page_allocation() {
        let page_manager = PageManager::new(PageManagerConfig::default());
        let page_id = page_manager.allocate_page().await.unwrap();
        
        assert!(page_id > 0);
        
        let page = page_manager.read_page(page_id).await.unwrap();
        assert_eq!(page.header.page_id, page_id);
    }
}
```

#### Интеграционные тесты

```rust
#[tokio::test]
async fn test_transaction_isolation() {
    let db = Database::connect(":memory:").await.unwrap();
    
    // Создать тестовую таблицу
    db.execute("CREATE TABLE test (id INTEGER, value INTEGER)").await.unwrap();
    db.execute("INSERT INTO test VALUES (1, 100)").await.unwrap();
    
    // Начать две транзакции
    let tx1 = db.begin_transaction(IsolationLevel::ReadCommitted).await.unwrap();
    let tx2 = db.begin_transaction(IsolationLevel::ReadCommitted).await.unwrap();
    
    // Транзакция 1 читает
    let result1 = tx1.execute("SELECT value FROM test WHERE id = 1").await.unwrap();
    assert_eq!(result1.rows[0].get::<i32>("value").unwrap(), 100);
    
    // Транзакция 2 обновляет
    tx2.execute("UPDATE test SET value = 200 WHERE id = 1").await.unwrap();
    tx2.commit().await.unwrap();
    
    // Транзакция 1 читает снова (должна видеть обновленное значение в ReadCommitted)
    let result2 = tx1.execute("SELECT value FROM test WHERE id = 1").await.unwrap();
    assert_eq!(result2.rows[0].get::<i32>("value").unwrap(), 200);
    
    tx1.commit().await.unwrap();
}
```

### Соображения производительности

1. **Управление памятью**: Используйте `Arc` и `Mutex` осмотрительно, чтобы избежать ненужного клонирования и блокировок
2. **Асинхронный ввод-вывод**: Используйте `tokio::fs` для файловых операций и `tokio::net` для сетевых операций
3. **Пул буферов**: Держите часто используемые страницы в памяти
4. **Использование индексов**: Создавайте подходящие индексы для распространенных паттернов запросов
5. **Оптимизация запросов**: Используйте статистику для принятия обоснованных решений по оптимизации

### Стандарты документации

1. **Документация API**: Используйте `///` для документации публичного API
2. **Комментарии к коду**: Объясняйте сложные алгоритмы и бизнес-логику
3. **Примеры**: Предоставляйте примеры использования для публичных API
4. **Архитектура**: Документируйте решения по проектированию и компромиссы

Эта техническая документация предоставляет исчерпывающий обзор внутренней архитектуры и деталей реализации RustDB. Для получения более конкретной информации об отдельных компонентах обратитесь к встроенной документации и исходному коду.
