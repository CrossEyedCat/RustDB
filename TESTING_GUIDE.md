# –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é RustBD

## üß™ –û–±–∑–æ—Ä

–≠—Ç–æ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –æ–ø–∏—Å—ã–≤–∞–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏ –ø—Ä–∞–∫—Ç–∏–∫–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ RustBD. –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –ø–æ–¥—Ö–æ–¥ –∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ –∏ –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã.

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

### –£—Ä–æ–≤–Ω–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    End-to-End Tests                        ‚îÇ
‚îÇ              (–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã —Å–∏—Å—Ç–µ–º—ã)                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                Integration Tests                           ‚îÇ
‚îÇ           (–¢–µ—Å—Ç—ã –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   Unit Tests                              ‚îÇ
‚îÇ              (–¢–µ—Å—Ç—ã –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π)                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                Property Tests                              ‚îÇ
‚îÇ           (–¢–µ—Å—Ç—ã —Å–≤–æ–π—Å—Ç–≤ –∏ –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üîß Unit —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ unit —Ç–µ—Å—Ç–æ–≤

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::*;

    #[test]
    fn test_function_name() {
        // Arrange - –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        let input = "test_data";
        
        // Act - –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–∏—Ä—É–µ–º–æ–≥–æ –∫–æ–¥–∞
        let result = function_under_test(input);
        
        // Assert - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        assert_eq!(result, expected_value);
    }

    #[test]
    fn test_function_with_error() {
        // Arrange
        let invalid_input = "invalid";
        
        // Act & Assert
        let result = function_under_test(invalid_input);
        assert!(result.is_err());
        
        match result.unwrap_err() {
            ExpectedError::InvalidInput { message } => {
                assert!(message.contains("invalid"));
            }
            _ => panic!("Expected InvalidInput error"),
        }
    }
}
```

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_page_creation() {
        // Arrange
        let page_id = PageId::new(1);
        let page_size = 4096;
        
        // Act
        let page = Page::new(page_id, page_size);
        
        // Assert
        assert_eq!(page.id(), page_id);
        assert_eq!(page.size(), page_size);
        assert_eq!(page.free_space(), page_size - Page::header_size());
        assert!(page.is_empty());
    }

    #[test]
    fn test_page_insert_record() {
        // Arrange
        let mut page = Page::new(PageId::new(1), 4096);
        let record = Record::new("test_data".as_bytes().to_vec());
        
        // Act
        let result = page.insert_record(&record);
        
        // Assert
        assert!(result.is_ok());
        assert!(!page.is_empty());
        assert_eq!(page.record_count(), 1);
        assert!(page.free_space() < 4096 - Page::header_size());
    }

    #[test]
    fn test_page_full_insertion() {
        // Arrange
        let mut page = Page::new(PageId::new(1), 100);
        let large_record = Record::new(vec![0u8; 200]); // –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π
        
        // Act
        let result = page.insert_record(&large_record);
        
        // Assert
        assert!(result.is_err());
        match result.unwrap_err() {
            PageError::RecordTooLarge { record_size, available_space } => {
                assert_eq!(record_size, 200);
                assert!(available_space < 200);
            }
            _ => panic!("Expected RecordTooLarge error"),
        }
    }
}
```

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::test;

    #[tokio::test]
    async fn test_async_connection() {
        // Arrange
        let config = ConnectionConfig::new()
            .host("localhost")
            .port(5432)
            .build()
            .unwrap();
        
        // Act
        let connection = DatabaseConnection::connect(&config).await;
        
        // Assert
        assert!(connection.is_ok());
        let conn = connection.unwrap();
        assert_eq!(conn.host(), "localhost");
        assert_eq!(conn.port(), 5432);
    }

    #[tokio::test]
    async fn test_connection_timeout() {
        // Arrange
        let config = ConnectionConfig::new()
            .host("invalid-host")
            .port(5432)
            .connection_timeout(Duration::from_millis(100))
            .build()
            .unwrap();
        
        // Act
        let start = Instant::now();
        let connection = DatabaseConnection::connect(&config).await;
        let duration = start.elapsed();
        
        // Assert
        assert!(connection.is_err());
        assert!(duration >= Duration::from_millis(100));
        assert!(duration < Duration::from_millis(200));
    }
}
```

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –º–æ–∫–∞–º–∏

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::predicate::*;
    use mockall::*;

    mock! {
        Storage {}
        
        impl Storage for Storage {
            async fn read_page(&self, page_id: PageId) -> Result<Page, StorageError>;
            async fn write_page(&self, page: &Page) -> Result<(), StorageError>;
        }
    }

    #[tokio::test]
    async fn test_buffer_manager_with_mock_storage() {
        // Arrange
        let mut mock_storage = MockStorage::new();
        let page_id = PageId::new(1);
        let page = Page::new(page_id, 4096);
        
        mock_storage
            .expect_read_page()
            .with(eq(page_id))
            .times(1)
            .returning(move |_| Ok(page.clone()));
        
        let buffer_manager = BufferManager::new(Arc::new(mock_storage));
        
        // Act
        let result = buffer_manager.get_page(page_id).await;
        
        // Assert
        assert!(result.is_ok());
        let retrieved_page = result.unwrap();
        assert_eq!(retrieved_page.id(), page_id);
    }
}
```

## üîó –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use crate::test_utils::TestDatabase;

    #[tokio::test]
    async fn test_full_query_execution() {
        // Arrange
        let db = TestDatabase::new().await;
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã
        let schema = TableSchema::new("users")
            .add_column("id", ColumnType::Integer, vec![ColumnConstraint::PrimaryKey])
            .add_column("name", ColumnType::Varchar(50), vec![ColumnConstraint::NotNull])
            .build()
            .unwrap();
        
        db.create_table(&schema).await.unwrap();
        
        // –í—Å—Ç–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        let insert_result = db.execute(
            "INSERT INTO users (name) VALUES (?)",
            &["John Doe"]
        ).await;
        assert!(insert_result.is_ok());
        
        // –í—ã–±–æ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        let select_result = db.query("SELECT * FROM users", &[]).await;
        assert!(select_result.is_ok());
        
        let rows = select_result.unwrap();
        assert_eq!(rows.len(), 1);
        assert_eq!(rows[0].get("name").unwrap(), "John Doe");
    }

    #[tokio::test]
    async fn test_transaction_rollback() {
        // Arrange
        let db = TestDatabase::new().await;
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã
        let schema = TableSchema::new("accounts")
            .add_column("id", ColumnType::Integer, vec![ColumnConstraint::PrimaryKey])
            .add_column("balance", ColumnType::Integer, vec![ColumnConstraint::NotNull])
            .build()
            .unwrap();
        
        db.create_table(&schema).await.unwrap();
        
        // –ù–∞—á–∞–ª–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        let transaction = db.begin_transaction().await.unwrap();
        
        // –í—Å—Ç–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        transaction.execute("INSERT INTO accounts (balance) VALUES (?)", &[&100]).await.unwrap();
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        let rows = transaction.query("SELECT * FROM accounts", &[]).await.unwrap();
        assert_eq!(rows.len(), 1);
        
        // –û—Ç–∫–∞—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        transaction.rollback().await.unwrap();
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å
        let rows = db.query("SELECT * FROM accounts", &[]).await.unwrap();
        assert_eq!(rows.len(), 0);
    }
}
```

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ—Ç–µ–≤–æ–≥–æ —Å–ª–æ—è

```rust
#[cfg(test)]
mod network_tests {
    use super::*;
    use tokio::net::TcpListener;

    #[tokio::test]
    async fn test_client_server_communication() {
        // Arrange
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let server_addr = listener.local_addr().unwrap();
        
        // –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–µ
        let server_handle = tokio::spawn(async move {
            let (socket, _) = listener.accept().await.unwrap();
            let mut server = DatabaseServer::new(socket);
            server.handle_connection().await.unwrap();
        });
        
        // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞
        let client = DatabaseClient::connect(&server_addr).await.unwrap();
        
        // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞
        let result = client.execute("SELECT 1").await;
        assert!(result.is_ok());
        
        // –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–µ—Ä–≤–µ—Ä–∞
        server_handle.await.unwrap().unwrap();
    }
}
```

## üìä Property-based —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ proptest

```rust
#[cfg(test)]
mod property_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn test_page_size_invariants(
            page_id in 1..1000u32,
            page_size in 1024..65536u32
        ) {
            // Arrange
            let page_id = PageId::new(page_id);
            let page_size = page_size;
            
            // Act
            let page = Page::new(page_id, page_size);
            
            // Assert - –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
            prop_assert!(page.size() >= 1024);
            prop_assert!(page.size() <= 65536);
            prop_assert!(page.free_space() <= page.size());
            prop_assert!(page.free_space() >= page.size() - Page::header_size());
        }

        #[test]
        fn test_record_insertion_properties(
            record_data in prop::collection::vec(any::<u8>(), 1..1000)
        ) {
            // Arrange
            let mut page = Page::new(PageId::new(1), 4096);
            let record = Record::new(record_data);
            
            // Act
            let result = page.insert_record(&record);
            
            // Assert - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ–π—Å—Ç–≤
            if record.size() <= page.free_space() {
                prop_assert!(result.is_ok());
                prop_assert!(!page.is_empty());
                prop_assert!(page.record_count() > 0);
            } else {
                prop_assert!(result.is_err());
            }
        }
    }
}
```

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏

```rust
#[cfg(test)]
mod serialization_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn test_page_serialization_roundtrip(
            page_id in 1..1000u32,
            page_size in 1024..65536u32
        ) {
            // Arrange
            let original_page = Page::new(PageId::new(page_id), page_size);
            
            // Act
            let serialized = bincode::serialize(&original_page).unwrap();
            let deserialized: Page = bincode::deserialize(&serialized).unwrap();
            
            // Assert - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–≤–æ–π—Å—Ç–≤
            prop_assert_eq!(original_page.id(), deserialized.id());
            prop_assert_eq!(original_page.size(), deserialized.size());
            prop_assert_eq!(original_page.free_space(), deserialized.free_space());
        }
    }
}
```

## üöÄ Performance —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### –ë–µ–Ω—á–º–∞—Ä–∫–∏

```rust
#[cfg(test)]
mod benchmarks {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn benchmark_page_insertion(c: &mut Criterion) {
        let mut group = c.benchmark_group("page_operations");
        
        group.bench_function("insert_small_record", |b| {
            b.iter(|| {
                let mut page = Page::new(PageId::new(1), 4096);
                let record = Record::new(black_box(vec![0u8; 100]));
                page.insert_record(&record).unwrap();
                page
            });
        });
        
        group.bench_function("insert_large_record", |b| {
            b.iter(|| {
                let mut page = Page::new(PageId::new(1), 4096);
                let record = Record::new(black_box(vec![0u8; 1000]));
                page.insert_record(&record).unwrap();
                page
            });
        });
        
        group.finish();
    }

    fn benchmark_buffer_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("buffer_operations");
        
        group.bench_function("lru_cache_hit", |b| {
            let buffer_manager = BufferManager::new(Arc::new(MockStorage::new()));
            let page_id = PageId::new(1);
            
            b.iter(|| {
                buffer_manager.get_page(page_id).unwrap();
            });
        });
        
        group.finish();
    }

    criterion_group!(benches, benchmark_page_insertion, benchmark_buffer_operations);
    criterion_main!(benches);
}
```

### –ù–∞–≥—Ä—É–∑–æ—á–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

```rust
#[cfg(test)]
mod stress_tests {
    use super::*;
    use tokio::task;

    #[tokio::test]
    async fn test_concurrent_connections() {
        // Arrange
        let db = TestDatabase::new().await;
        let connection_count = 100;
        
        // Act - —Å–æ–∑–¥–∞–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
        let handles: Vec<_> = (0..connection_count)
            .map(|i| {
                let db_clone = db.clone();
                task::spawn(async move {
                    let result = db_clone.execute("SELECT ?", &[&i]).await;
                    (i, result)
                })
            })
            .collect();
        
        // Assert - –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
        for handle in handles {
            let (id, result) = handle.await.unwrap();
            assert!(result.is_ok(), "Connection {} failed: {:?}", id, result);
        }
    }

    #[tokio::test]
    async fn test_high_concurrency_queries() {
        // Arrange
        let db = TestDatabase::new().await;
        let query_count = 1000;
        let concurrent_tasks = 10;
        
        // Act - –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        let handles: Vec<_> = (0..concurrent_tasks)
            .map(|_| {
                let db_clone = db.clone();
                task::spawn(async move {
                    for i in 0..(query_count / concurrent_tasks) {
                        let result = db_clone.execute("SELECT ?", &[&i]).await;
                        assert!(result.is_ok());
                    }
                })
            })
            .collect();
        
        // Assert - –æ–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
        for handle in handles {
            handle.await.unwrap();
        }
    }
}
```

## üßπ –¢–µ—Å—Ç–æ–≤—ã–µ —É—Ç–∏–ª–∏—Ç—ã

### TestDatabase

```rust
pub mod test_utils {
    use super::*;
    use tempfile::TempDir;
    use std::sync::Arc;

    /// –¢–µ—Å—Ç–æ–≤–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤
    pub struct TestDatabase {
        data_dir: TempDir,
        database: Arc<Database>,
    }

    impl TestDatabase {
        /// –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Ç–µ—Å—Ç–æ–≤—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        pub async fn new() -> Self {
            let data_dir = TempDir::new().unwrap();
            let config = DatabaseConfig::new()
                .data_directory(data_dir.path())
                .build()
                .unwrap();
            
            let database = Database::new(config).await.unwrap();
            
            Self {
                data_dir,
                database: Arc::new(database),
            }
        }

        /// –°–æ–∑–¥–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö —Å –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–π —Å—Ö–µ–º–æ–π
        pub async fn with_schema(schema_sql: &str) -> Self {
            let db = Self::new().await;
            
            // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ SQL –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ö–µ–º—ã
            db.execute(schema_sql, &[]).await.unwrap();
            
            db
        }

        /// –û—á–∏—â–∞–µ—Ç –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –≤ —Ç–µ—Å—Ç–æ–≤–æ–π –±–∞–∑–µ
        pub async fn clear(&self) -> Result<(), DatabaseError> {
            // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ç–∞–±–ª–∏—Ü
            let tables = self.query(
                "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'",
                &[]
            ).await?;
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö —Ç–∞–±–ª–∏—Ü
            for table in tables {
                let table_name: String = table.get("table_name")?.try_into()?;
                self.execute(&format!("DROP TABLE IF EXISTS {}", table_name), &[]).await?;
            }
            
            Ok(())
        }

        /// –£–Ω–∏—á—Ç–æ–∂–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        pub async fn destroy(self) -> Result<(), DatabaseError> {
            // –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            self.database.shutdown().await?;
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            self.data_dir.close().unwrap();
            
            Ok(())
        }
    }

    impl std::ops::Deref for TestDatabase {
        type Target = Database;

        fn deref(&self) -> &Self::Target {
            &self.database
        }
    }

    impl std::ops::DerefMut for TestDatabase {
        fn deref_mut(&mut self) -> &mut Self::Target {
            Arc::get_mut(&mut self.database).unwrap()
        }
    }
}
```

### –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ

```rust
pub mod test_data {
    use super::*;

    /// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
    pub fn generate_test_users(count: usize) -> Vec<User> {
        (0..count)
            .map(|i| User {
                id: i as u32,
                username: format!("user_{}", i),
                email: format!("user_{}@example.com", i),
                created_at: Utc::now(),
            })
            .collect()
    }

    /// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏ –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã
    pub fn generate_test_records(count: usize) -> Vec<Record> {
        (0..count)
            .map(|i| Record::new(format!("record_{}", i).as_bytes().to_vec()))
            .collect()
    }

    /// –°–æ–∑–¥–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é —Å—Ö–µ–º—É —Ç–∞–±–ª–∏—Ü—ã
    pub fn create_test_table_schema() -> TableSchema {
        TableSchema::new("test_table")
            .add_column("id", ColumnType::Integer, vec![ColumnConstraint::PrimaryKey])
            .add_column("name", ColumnType::Varchar(100), vec![ColumnConstraint::NotNull])
            .add_column("value", ColumnType::Integer, vec![])
            .build()
            .unwrap()
    }
}
```

## üîç –û—Ç–ª–∞–¥–∫–∞ —Ç–µ—Å—Ç–æ–≤

### –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ —Ç–µ—Å—Ç–∞—Ö

```rust
#[cfg(test)]
mod debug_tests {
    use super::*;
    use tracing::{info, warn, error};

    #[tokio::test]
    async fn test_with_logging() {
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è —Ç–µ—Å—Ç–æ–≤
        tracing_subscriber::fmt()
            .with_env_filter("debug")
            .init();

        info!("–ù–∞—á–∏–Ω–∞–µ–º —Ç–µ—Å—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö");
        
        let db = TestDatabase::new().await;
        info!("–¢–µ—Å—Ç–æ–≤–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —Å–æ–∑–¥–∞–Ω–∞");
        
        // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–∞
        let result = db.execute("SELECT 1", &[]).await;
        
        match result {
            Ok(_) => info!("–¢–µ—Å—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ"),
            Err(e) => {
                error!("–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π: {:?}", e);
                panic!("–¢–µ—Å—Ç –Ω–µ –¥–æ–ª–∂–µ–Ω –∑–∞–≤–µ—Ä—à–∞—Ç—å—Å—è —Å –æ—à–∏–±–∫–æ–π");
            }
        }
    }
}
```

### –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤

```rust
#[cfg(test)]
mod visualization_tests {
    use super::*;

    #[test]
    fn test_page_structure_visualization() {
        let page = Page::new(PageId::new(1), 4096);
        
        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        println!("Page Structure:");
        println!("  ID: {}", page.id());
        println!("  Size: {} bytes", page.size());
        println!("  Free Space: {} bytes", page.free_space());
        println!("  Record Count: {}", page.record_count());
        
        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –º–∞–∫–µ—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        println!("Page Layout:");
        println!("  [Header: {} bytes]", Page::header_size());
        println!("  [Records: {} bytes]", page.size() - page.free_space() - Page::header_size());
        println!("  [Free Space: {} bytes]", page.free_space());
        
        assert!(page.is_empty());
    }
}
```

## üìä –ú–µ—Ç—Ä–∏–∫–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

### –ü–æ–∫—Ä—ã—Ç–∏–µ –∫–æ–¥–∞

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ cargo-tarpaulin
cargo install cargo-tarpaulin

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–∫—Ä—ã—Ç–∏—è
cargo tarpaulin --out Html

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–∫—Ä—ã—Ç–∏—è —Å –∏—Å–∫–ª—é—á–µ–Ω–∏—è–º–∏
cargo tarpaulin --exclude-files "tests/*" --out Html
```

### –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ cargo-flamegraph
cargo install flamegraph

# –°–æ–∑–¥–∞–Ω–∏–µ flamegraph –¥–ª—è —Ç–µ—Å—Ç–æ–≤
cargo flamegraph --test test_name

# –ê–Ω–∞–ª–∏–∑ –ø–∞–º—è—Ç–∏
cargo install cargo-valgrind
cargo valgrind test test_name
```

## üö® –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ —Ç–µ—Å—Ç–∞—Ö

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫

```rust
#[cfg(test)]
mod error_tests {
    use super::*;

    #[test]
    fn test_database_errors() {
        // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ—à–∏–±–æ–∫
        let connection_error = DatabaseError::ConnectionError {
            message: "Connection failed".to_string(),
        };
        
        let sql_error = DatabaseError::SqlError {
            sql: "SELECT * FROM invalid_table".to_string(),
            details: "Table does not exist".to_string(),
        };
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–∞—Ö
        assert!(connection_error.to_string().contains("Connection failed"));
        assert!(sql_error.to_string().contains("SELECT * FROM invalid_table"));
        assert!(sql_error.to_string().contains("Table does not exist"));
    }

    #[test]
    fn test_error_conversion() {
        // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –æ—à–∏–±–æ–∫
        let io_error = std::io::Error::new(
            std::io::ErrorKind::ConnectionRefused,
            "Connection refused"
        );
        
        let db_error: DatabaseError = io_error.into();
        
        match db_error {
            DatabaseError::IoError(_) => (), // –û–∂–∏–¥–∞–µ–º—ã–π —Ç–∏–ø
            _ => panic!("Expected IoError"),
        }
    }
}
```

## üìö –õ—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏

### –û–±—â–∏–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã

1. **–ò–∑–æ–ª—è—Ü–∏—è**: –ö–∞–∂–¥—ã–π —Ç–µ—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–º
2. **–î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç—å**: –¢–µ—Å—Ç—ã –¥–æ–ª–∂–Ω—ã –¥–∞–≤–∞—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—É—Å–∫–µ
3. **–ë—ã—Å—Ç—Ä–æ—Ç–∞**: –¢–µ—Å—Ç—ã –¥–æ–ª–∂–Ω—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å—Å—è –±—ã—Å—Ç—Ä–æ
4. **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å**: –¢–µ—Å—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ø–æ–Ω—è—Ç–Ω—ã–º–∏ –∏ —Å–∞–º–æ–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–µ–º—ã–º–∏
5. **–ü–æ–¥–¥–µ—Ä–∂–∫–∞**: –¢–µ—Å—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ª–µ–≥–∫–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–º–∏

### –û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤

1. **–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞**: –ì—Ä—É–ø–ø–∏—Ä—É–π—Ç–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –≤ –º–æ–¥—É–ª–∏
2. **–ò–º–µ–Ω–æ–≤–∞–Ω–∏–µ**: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω—ã–µ –∏–º–µ–Ω–∞ –¥–ª—è —Ç–µ—Å—Ç–æ–≤
3. **–°—Ç—Ä—É–∫—Ç—É—Ä–∞**: –°–ª–µ–¥—É–π—Ç–µ –ø–∞—Ç—Ç–µ—Ä–Ω—É Arrange-Act-Assert
4. **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**: –ö–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ —Å–ª–æ–∂–Ω—ã–µ —Ç–µ—Å—Ç—ã

### –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏

1. **–§–∏–∫—Å—Ç—É—Ä—ã**: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–∏–∫—Å—Ç—É—Ä—ã –¥–ª—è –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –¥–∞–Ω–Ω—ã—Ö
2. **–§–∞–±—Ä–∏–∫–∏**: –°–æ–∑–¥–∞–≤–∞–π—Ç–µ —Ñ–∞–±—Ä–∏–∫–∏ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
3. **–û—á–∏—Å—Ç–∫–∞**: –í—Å–µ–≥–¥–∞ –æ—á–∏—â–∞–π—Ç–µ —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
4. **–ò–∑–æ–ª—è—Ü–∏—è**: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–µ—Å—Ç–∞

## üîó –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã

- [Rust Book - Testing](https://doc.rust-lang.org/book/ch11-00-testing.html)
- [Rust Testing Guide](https://rust-lang.github.io/rustc-guide/tests.html)
- [Criterion.rs](https://github.com/bheisler/criterion.rs)
- [proptest](https://github.com/AltSysrq/proptest)
- [mockall](https://github.com/asomers/mockall)

–°–ª–µ–¥—É—è —ç—Ç–∏–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º, –≤—ã —Å–æ–∑–¥–∞–¥–∏—Ç–µ –Ω–∞–¥–µ–∂–Ω—É—é –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—É—é —Å–∏—Å—Ç–µ–º—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è RustBD.
